#!/bin/bash

# создать массив
arr=(one two three)
arr[3]="4"
arr[4]="5"

echo "${arr[@]}"                        # чтение всех элементов
echo "${arr[*]}"                        # все элементы одной строкой
echo "${#arr[@]}"                       # количество элементов
echo "${!arr[@]}"                       # Список индексов > 0 1 2 3 4

arr[1]="TWO"                            # Замена элемента по индексу

# массовая замена через цикл
for i in "${!arr[@]}"; do
    arr[$i]="${arr[$i]}_X"
done
echo "${arr[@]}"


unset arr[1]                            # удаления элемента, индекс тоже удаляется, 
echo "${!arr[@]}"                       # Список индексов > 0 2 3 4
arr=(${arr[@]})                         # пересчитать индексы массива
echo "${arr[@]}"
echo "${!arr[@]}"

arr+=(four)                             # Добавление элемента в конец массива
arr[10]="ten"                           # Добавление элемента по индексу
# -------------------------------------------------------------------------------
# clice формат: ${array[@]:start:length}
arr=(one two three four five)
arr_slice=("${arr[@]:0:3}")
echo "${arr[@]:3}"
echo "${arr[@]}"                           # one two three four five
echo "${arr_slice[@]}"                     #     two three four
# ==============================================================================

# поиск по массиву (есть ли точное совпадение) 
value="two"
found=false

for x in "${arr_slice[@]}"; do
    [ "${x}" = "${value}" ] && found=true
done
echo "${found}"
# -------------------------------------------------------------------------------
# поиск индекса элемента
for x in "${!arr_slice[@]}"; do
    [ "${arr_slice[${x}]}" = "${value}" ] && echo "Index: ${x}"
done
# -------------------------------------------------------------------------------
# проверка на существование элемента
[ -v arr_slice[1] ] && echo "exists"
# проверка на массив пуст?
(( "${#arr_slice[@]}" == 0 )) && echo "empty"
# -------------------------------------------------------------------------------
# Копирование массива
copy_arr=("${arr[@]}")

# ==============================================================================
# Сортировка числового массива
arr_int=(2 9 10 99 1 0)
sorted=($(printf "%s\n" "${arr_int[@]}" | sort -n)) 
sorted=($(printf "%s\n" "${arr_int[@]}" | sort -rn))    # обратная сортировка 
echo "${sorted[@]}"
# ==============================================================================
# Удаление, замена элемента по значению (Удаляет первое совпадение) 
value="two"
arr=(one two three)
echo "${arr[@]}"
arr=("${arr[@]/$value/"here"}")     # замена первого найденого элемента
# arr=("${arr[@]/$value}")            # раменить элемент на пустую сроку
echo "${arr[@]}"
# -------------------------------------------------------------------------------
# удалить элемент через интекс
for i in "${!arr[@]}"; do
    [[ "${arr["$i"]}" == "here" ]] && unset arr["${i}"]
done
arr=("${arr[@]}") && echo "${!arr[@]}"      # выравниваем индексы и выводим их на экран


# ===========================================================================================
# ===========================================================================================

# mapfile это лучший инструмент для чтения строк в массив.
# mapfile (он же readarray) — builtin Bash, который читает stdin построчно и кладёт строки в массив.
# mapfile array

mapfile -t screens < <(xrandr --query | awk '/ connected/{print $1}')
# -t обрезает '\n' в конце строк
# < <(...) — process substitution (замена процесса)

# пример:
monitor_brightness() {
  local n="$1"
  mapfile -t screens < <(xrandr --query | awk '/ connected/{print $1}')

  for screen in "${screens[@]}"; do
    xrandr --output "$screen" --brightness "$n"
  done
} 
monitor_brightness 1

exit 0
