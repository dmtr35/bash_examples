#!/bin/bash

printf(FORMAT, ARG1, ARG2, ...)
printf FORMAT [ARGUMENT...]
printf -v var FORMAT [ARGUMENT...]
# FORMAT — управляющая строка
# Аргументы подставляются строго слева направо
# FORMAT переиспользуется, если аргументов больше
# =======================================================

# Escape-последовательности
# Последовательность	    ASCII	    Эффект
# \n	                    0x0a	    Новая строка
# \r	                    0x0d	    В начало строки
# \b	                    0x08	    Назад на 1 символ
# \t	                    0x09	    Таб
# \v	                    0x0b	    Вертикальный таб
# \f	                    0x0c	    Form feed
# \\	                    0x5c	    \
# \"	                    0x22	    "
# \0NNN	                    octal	    Произвольный байт
# \xHH	                    hex	        Произвольный байт

# =======================================================
# байтовый вывод:
printf "\x41\x42\x43\n"                                         # -> ABC
printf %i "'A"                                                  # -> '65'
printf %x "'A"                                                  # -> '41'

# =======================================================
# Формат-спецификаторы
# Спецификатор	Описание
# %s	            строка
# %c	            один символ (ASCII)         

printf "%c" g                                                   # -> g
printf "%s %b\n" hello '\x41'                                   # -> hello A

# =======================================================

# Целые числа
# Спецификатор              Основание
# %d / %i	                десятичное                          printf "%d" 10      ->      10
# %u                        беззнаковое                         printf "%d" -10     ->      18446744073709551606
# %o                        восьмеричное                        printf "%o\n" 10    ->      12
# %x                        hex (lower)                         printf "%x\n" 10    ->      a
# %X                        hex (upper)                         printf "%X\n" 10    ->      A

# =======================================================

# Ширина и выравнивание
printf "%8s\n" hi                                               # -> '      hi'
printf "%-8s%s\n" hi dm                                         # -> 'hi      dm'
printf "%04d\n" 7                                               # -> '0007'

# =======================================================

# %b — интерпретирует escape-последовательности в аргументе, а не в формате.
# Это единственный безопасный способ передать управляющие байты из переменной.
printf "%b\n" "va\br"                                           # -> 'vr'

# пример эксплуатации:
payload='AAAA\b\b\x00'
printf "%b" "$payload"                                          # -> 'AA'

# =======================================================

# %q — shell-quoting
# Выводит экранированную версию аргумента, которую можно повторно использовать в качестве входных данных
printf "%q\n" 'a b $c'                                          # -> 'a\ b\ \$c'

# =======================================================

# %(fmt)T — время (Bash-расширение)
printf "%(%Y-%m-%d %H:%M:%S)T\n" -1                             # '2025-12-28 16:57:46'
# -1 - текущее время
# fmt → формат strftime(3)

# =======================================================

# -v var — вывод без stdout
# Опция -v присваивает результат переменной вместо вывода в стандартный поток вывода.
printf -v buf "%08x" 3735928559                                 # запить в переменную buf
echo $buf                                                       # 'deadbeef'

# =======================================================

# Переиспользование FORMAT
# FORMAT применяется циклически, пока не будут израсходованы все ARGUMENTS
printf "%s:%s\n" one two three four five
# -> 'one:two'
# -> 'three:four'
# -> 'five:'

# =======================================================

printf '<%s>\n' "$(date)"
# <Сб 10 янв 2026 19:07:31 EET>
printf '<%s>\n' $(date)
# <Сб>
# <10>
# <янв>
# <2026>
# <19:07:35>
# <EET>






exit 0